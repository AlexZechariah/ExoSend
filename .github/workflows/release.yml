name: ExoSend Release

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write
  packages: write

env:
  BUILD_CONFIGURATION: Release
  FEED_URL: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json
  VCPKG_BINARY_SOURCES: 'clear;default,readwrite'

jobs:
  decide:
    name: Decide Release
    runs-on: windows-latest

    outputs:
      do_release: ${{ steps.decide.outputs.do_release }}
      tag: ${{ steps.decide.outputs.tag }}
      version: ${{ steps.decide.outputs.version }}

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    - name: Decide whether to publish
      id: decide
      env:
        REF: ${{ github.ref }}
        REF_NAME: ${{ github.ref_name }}
        SHA: ${{ github.sha }}
      run: |
        $ErrorActionPreference = 'Stop'

        function Parse-VersionFromCMakeText([string] $text) {
          $pattern = 'project\s*\(\s*ExoSend\s+VERSION\s+([0-9]+)\.([0-9]+)\.([0-9]+)'
          try {
            [void][regex]::new($pattern)
          } catch {
            throw "Invalid version regex: $pattern. $($_.Exception.Message)"
          }

          if ($text -match $pattern) {
            return @{
              Major = [int]$Matches[1]
              Minor = [int]$Matches[2]
              Patch = [int]$Matches[3]
              Version = "$($Matches[1]).$($Matches[2]).$($Matches[3])"
            }
          }
          return $null
        }

        $isTagPush = $env:REF -like 'refs/tags/*'

        $cmakeText = Get-Content -Path 'CMakeLists.txt' -Raw
        $current = Parse-VersionFromCMakeText $cmakeText
        if (-not $current) {
          throw "Could not parse ExoSend VERSION from CMakeLists.txt."
        }

        $tag = if ($isTagPush) { $env:REF_NAME } else { "v$($current.Version)" }

        git fetch --tags --force
        if ($LASTEXITCODE -ne 0) {
          throw "git fetch --tags failed with exit code $LASTEXITCODE."
        }

        $remoteTagExists = $false
        $remoteTagLines = git ls-remote --tags origin ("refs/tags/" + $tag)
        if ($LASTEXITCODE -ne 0) {
          throw "git ls-remote failed with exit code $LASTEXITCODE."
        }
        if ($remoteTagLines) {
          $remoteTagExists = $true
        }

        if ($isTagPush) {
          Write-Host "Tag push detected ($tag). Publishing is enabled."
          "do_release=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "version=$($current.Version)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          exit 0
        }

        # Auto-publish policy (branch push):
        #
        # Publish when HEAD is an explicit release commit matching the version in
        # CMakeLists.txt, and the corresponding tag does not already exist on the
        # remote. Checking HEAD directly (rather than a BEFORE_SHA..SHA range)
        # avoids failures when BEFORE_SHA is not reachable in the local clone.

        $expectedReleaseSubject = "chore(release): v$($current.Version)"
        $hasReleaseCommit = $false

        $headSubject = (git log -1 --pretty=format:%s) 2>$null
        if ($LASTEXITCODE -eq 0 -and $headSubject -eq $expectedReleaseSubject) {
          $hasReleaseCommit = $true
        } else {
          $LASTEXITCODE = 0
        }

        $doRelease = $hasReleaseCommit -and (-not $remoteTagExists)

        Write-Host "Event: push to main"
        Write-Host "Current version: $($current.Version)"
        Write-Host "Expected release subject: $expectedReleaseSubject"
        Write-Host "Release commit in push: $hasReleaseCommit"
        Write-Host "Remote tag exists ($tag): $remoteTagExists"
        Write-Host "Do release: $doRelease"

        $doReleaseFlag = if ($doRelease) { 'true' } else { 'false' }
        "do_release=$doReleaseFlag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        "tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        "version=$($current.Version)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        exit 0

  build-and-release:
    name: Build and Publish (Windows)
    needs: decide
    if: needs.decide.outputs.do_release == 'true'
    runs-on: windows-latest

    steps:
    # =========================================================================
    # Checkout Repository
    # =========================================================================
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    # =========================================================================
    # Install Qt6 (pre-built MSVC 2022 x64 binaries - downloaded, not compiled)
    # =========================================================================
    - name: Install Qt6
      uses: jurplel/install-qt-action@v4
      with:
        version: '6.8.3'
        arch: 'win64_msvc2022_64'
        cache: true

    # =========================================================================
    # Setup vcpkg
    # =========================================================================
    - name: Setup vcpkg
      uses: lukka/run-vcpkg@v11
      with:
        vcpkgGitCommitId: '39922dbab0cafd7a7150d459c6a181c7dee5dfbe'
        vcpkgJsonGlob: 'vcpkg.json'

    # =========================================================================
    # Cache vcpkg Dependencies
    # =========================================================================
    - name: Cache vcpkg Packages
      uses: actions/cache@v4
      with:
        path: |
          ${{ env.VCPKG_ROOT }}/archives
          ${{ env.VCPKG_ROOT }}/downloads
          build/vcpkg_installed
        key: ${{ runner.os }}-vcpkg-${{ hashFiles('vcpkg.json') }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-

    # =========================================================================
    # Configure vcpkg GitHub Packages binary caching (NuGet)
    # =========================================================================
    - name: Configure vcpkg binary cache (NuGet)
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        $ErrorActionPreference = 'Stop'

        $vcpkgExe = Join-Path $env:VCPKG_ROOT 'vcpkg.exe'
        if (-not (Test-Path $vcpkgExe)) {
          throw "vcpkg.exe not found at '$vcpkgExe'"
        }

        $nugetExe = & $vcpkgExe fetch nuget
        if (-not (Test-Path $nugetExe)) {
          throw "nuget.exe not found at '$nugetExe'"
        }
        if ([string]::IsNullOrWhiteSpace($env:GITHUB_TOKEN)) {
          throw "GITHUB_TOKEN is empty; cannot configure NuGet binary cache."
        }
        if ([string]::IsNullOrWhiteSpace($env:FEED_URL)) {
          throw "FEED_URL is empty; cannot configure NuGet binary cache."
        }

        $nugetConfigPath = Join-Path $env:RUNNER_TEMP 'vcpkg-nuget.config'
        $feedUrlEscaped = [System.Security.SecurityElement]::Escape($env:FEED_URL)
        $nugetConfigContent = @"
        <?xml version="1.0" encoding="utf-8"?>
        <configuration>
          <config>
            <add key="defaultPushSource" value="$feedUrlEscaped" />
          </config>
          <packageSources>
            <clear />
            <add key="GitHub" value="$feedUrlEscaped" />
          </packageSources>
          <packageSourceCredentials>
            <GitHub>
              <add key="Username" value="%GITHUB_ACTOR%" />
              <add key="ClearTextPassword" value="%GITHUB_TOKEN%" />
            </GitHub>
          </packageSourceCredentials>
          <apikeys>
            <add key="$feedUrlEscaped" value="%GITHUB_TOKEN%" />
          </apikeys>
        </configuration>
        "@
        [System.IO.File]::WriteAllText($nugetConfigPath, $nugetConfigContent, [System.Text.UTF8Encoding]::new($false))
        "VCPKG_NUGET_CONFIG_PATH=$nugetConfigPath" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

        "VCPKG_BINARY_SOURCES=clear;nugetconfig,$nugetConfigPath,readwrite;default,readwrite" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

    # =========================================================================
    # Locate VsDevCmd (MSVC + Windows SDK environment)
    # =========================================================================
    - name: Locate VsDevCmd
      shell: pwsh
      run: |
        $ErrorActionPreference = 'Stop'

        $vswhere = Join-Path ${env:ProgramFiles(x86)} 'Microsoft Visual Studio\Installer\vswhere.exe'
        if (-not (Test-Path $vswhere)) {
          throw "vswhere.exe not found at '$vswhere'"
        }

        $installPath = & $vswhere -latest -products * -requires Microsoft.VisualStudio.Component.VC.Tools.x86.x64 -property installationPath
        if ([string]::IsNullOrWhiteSpace($installPath)) {
          throw "vswhere.exe did not return a Visual Studio installation path with VC tools."
        }

        $vsDevCmd = Join-Path $installPath 'Common7\Tools\VsDevCmd.bat'
        if (-not (Test-Path $vsDevCmd)) {
          throw "VsDevCmd.bat not found at expected path: $vsDevCmd"
        }

        "VSDEVCMD=$vsDevCmd" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

    # =========================================================================
    # Configure CMake
    # =========================================================================
    - name: Configure CMake
      shell: cmd
      run: |
        call "%VSDEVCMD%" -no_logo -arch=x64 -host_arch=x64
        set CC=cl
        set CXX=cl
        cmake --preset windows

    # =========================================================================
    # Build Project
    # =========================================================================
    - name: Build ExoSend
      shell: cmd
      run: |
        call "%VSDEVCMD%" -no_logo -arch=x64 -host_arch=x64
        cmake --build build --config %BUILD_CONFIGURATION% --parallel

    # =========================================================================
    # Run Unit Tests
    # =========================================================================
    - name: Run Unit Tests
      run: |
        ctest --test-dir build -C ${{ env.BUILD_CONFIGURATION }} --verbose --output-on-failure --no-tests=error

    # =========================================================================
    # Build Installer (Inno Setup)
    # =========================================================================
    - name: Install Inno Setup
      run: |
        choco install innosetup -y

    - name: Build Installer
      run: |
        $ErrorActionPreference = 'Stop'

        $iscc = "${env:ProgramFiles(x86)}\\Inno Setup 6\\ISCC.exe"
        if (-not (Test-Path $iscc)) {
          throw "ISCC.exe not found at '$iscc'"
        }

        & $iscc "installers\\ExoSend.iss"

        $installerPath = "build\\installer\\ExoSend Installer.exe"
        if (-not (Test-Path $installerPath)) {
          throw "Installer output not found at '$installerPath'"
        }

    # =========================================================================
    # Package Release ZIP
    # =========================================================================
    - name: Package ZIP
      run: |
        $ErrorActionPreference = 'Stop'

        $buildDir = "build/bin/${{ env.BUILD_CONFIGURATION }}"
        $distDir = "dist"
        $stageDir = Join-Path $distDir "ExoSend"
        $zipPath = Join-Path $distDir "ExoSend.zip"

        if (-not (Test-Path $buildDir)) {
          throw "Build output directory not found: $buildDir"
        }

        Remove-Item -Recurse -Force $stageDir -ErrorAction SilentlyContinue
        New-Item -ItemType Directory -Path $stageDir -Force | Out-Null

        Copy-Item (Join-Path $buildDir "ExoSend.exe") $stageDir -Force
        Copy-Item (Join-Path $buildDir "ExoSendFirewallHelper.exe") $stageDir -Force
        Copy-Item (Join-Path $buildDir "ExoSendReset.exe") $stageDir -Force
        Copy-Item (Join-Path $buildDir "ExoSendRelaunch.exe") $stageDir -Force
        Copy-Item (Join-Path $buildDir "*.dll") $stageDir -Force
        Copy-Item (Join-Path $buildDir "platforms") $stageDir -Recurse -Force
        Copy-Item (Join-Path $buildDir "styles") $stageDir -Recurse -Force

        $required = @(
          (Join-Path $stageDir "ExoSend.exe"),
          (Join-Path $stageDir "ExoSendFirewallHelper.exe"),
          (Join-Path $stageDir "ExoSendReset.exe"),
          (Join-Path $stageDir "ExoSendRelaunch.exe"),
          (Join-Path $stageDir "Qt6Core.dll"),
          (Join-Path $stageDir "Qt6Gui.dll"),
          (Join-Path $stageDir "Qt6Widgets.dll"),
          (Join-Path $stageDir "libcrypto-3-x64.dll"),
          (Join-Path $stageDir "libssl-3-x64.dll"),
          (Join-Path $stageDir "platforms\\qwindows.dll"),
          (Join-Path $stageDir "styles\\qmodernwindowsstyle.dll")
        )

        $missing = $required | Where-Object { -not (Test-Path $_) }
        if ($missing.Count -gt 0) {
          $missing | ForEach-Object { Write-Host "Missing required runtime file: $_" }
          throw "Deployment completeness check failed."
        }

        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
        Compress-Archive -Path (Join-Path $stageDir "*") -DestinationPath $zipPath -Force

        Write-Host "Created: $zipPath"

    # =========================================================================
    # Publish GitHub Release
    # =========================================================================
    - name: Publish GitHub Release
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        $ErrorActionPreference = 'Stop'

        $tag = "${{ needs.decide.outputs.tag }}"
        $repo = "${{ github.repository }}"
        $sha = "${{ github.sha }}"
        $zipPath = "dist/ExoSend.zip"
        $installerPath = "build/installer/ExoSend Installer.exe"

        if (-not (Test-Path $zipPath)) {
          throw "ZIP not found at '$zipPath'"
        }
        if (-not (Test-Path $installerPath)) {
          throw "Installer not found at '$installerPath'"
        }

        $prerelease = $false
        if ($tag -match '^v0\\.') {
          $prerelease = $true
        }

        gh release view $tag --repo $repo *> $null
        $exists = ($LASTEXITCODE -eq 0)

        if (-not $exists) {
          $args = @($tag, $zipPath, $installerPath, "--repo", $repo, "--generate-notes", "--target", $sha)
          if ($prerelease) {
            $args += "--prerelease"
          }
          gh release create @args
        } else {
          gh release upload $tag $zipPath $installerPath --repo $repo --clobber
        }

    # =========================================================================
    # Cleanup Temporary NuGet Config
    # =========================================================================
    - name: Cleanup temporary NuGet config
      if: always()
      run: |
        $ErrorActionPreference = 'Continue'
        if (-not [string]::IsNullOrWhiteSpace($env:VCPKG_NUGET_CONFIG_PATH) -and (Test-Path $env:VCPKG_NUGET_CONFIG_PATH)) {
          Remove-Item -Path $env:VCPKG_NUGET_CONFIG_PATH -Force -ErrorAction Stop
          Write-Host "Temporary NuGet config removed."
        } else {
          Write-Host "No temporary NuGet config to remove."
        }
