name: ExoSend Release

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write
  packages: write

env:
  BUILD_CONFIGURATION: Release
  FEED_URL: https://nuget.pkg.github.com/${{ github.repository_owner }}/index.json
  VCPKG_BINARY_SOURCES: 'clear;default,readwrite'
  VCPKG_OVERLAY_PORTS: ${{ github.workspace }}\\vcpkg-overlays\\ports

jobs:
  decide:
    name: Decide Release
    runs-on: windows-latest

    outputs:
      do_release: ${{ steps.decide.outputs.do_release }}
      tag: ${{ steps.decide.outputs.tag }}
      version: ${{ steps.decide.outputs.version }}

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    - name: Decide whether to publish
      id: decide
      env:
        BEFORE_SHA: ${{ github.event.before }}
        REF: ${{ github.ref }}
        REF_NAME: ${{ github.ref_name }}
        SHA: ${{ github.sha }}
      run: |
        $ErrorActionPreference = 'Stop'

        function Parse-VersionFromCMakeText([string] $text) {
          $pattern = 'project\s*\(\s*ExoSend\s+VERSION\s+([0-9]+)\.([0-9]+)\.([0-9]+)'
          try {
            [void][regex]::new($pattern)
          } catch {
            throw "Invalid version regex: $pattern. $($_.Exception.Message)"
          }

          if ($text -match $pattern) {
            return @{
              Major = [int]$Matches[1]
              Minor = [int]$Matches[2]
              Patch = [int]$Matches[3]
              Version = "$($Matches[1]).$($Matches[2]).$($Matches[3])"
            }
          }
          return $null
        }

        $isTagPush = $env:REF -like 'refs/tags/*'

        $cmakeText = Get-Content -Path 'CMakeLists.txt' -Raw
        $current = Parse-VersionFromCMakeText $cmakeText
        if (-not $current) {
          throw "Could not parse ExoSend VERSION from CMakeLists.txt."
        }

        $tag = if ($isTagPush) { $env:REF_NAME } else { "v$($current.Version)" }

        git fetch --tags --force
        if ($LASTEXITCODE -ne 0) {
          throw "git fetch --tags failed with exit code $LASTEXITCODE."
        }

        $remoteTagExists = $false
        $remoteTagLines = git ls-remote --tags origin ("refs/tags/" + $tag)
        if ($LASTEXITCODE -ne 0) {
          throw "git ls-remote failed with exit code $LASTEXITCODE."
        }
        if ($remoteTagLines) {
          $remoteTagExists = $true
        }

        if ($isTagPush) {
          Write-Host "Tag push detected ($tag). Publishing is enabled."
          "do_release=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          "version=$($current.Version)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          exit 0
        }

        # Auto-publish policy (branch push):
        # - Only publish when version is 0.x.0 (patch == 0)
        # - Only publish when the version changed in this push compared to the previous remote HEAD
        # - Only publish when the tag does not already exist on the remote
        $isEligibleVersion = ($current.Major -eq 0) -and ($current.Patch -eq 0)

        $prevVersion = $null
        $before = $env:BEFORE_SHA
        if (-not [string]::IsNullOrWhiteSpace($before) -and ($before -notmatch '^0+$')) {
          $prevCmake = (git show ($before + ":CMakeLists.txt")) 2>$null
          if ($LASTEXITCODE -eq 0 -and -not [string]::IsNullOrWhiteSpace($prevCmake)) {
            $prevParsed = Parse-VersionFromCMakeText $prevCmake
            if ($prevParsed) {
              $prevVersion = $prevParsed.Version
            }
          } else {
            # Ensure a tolerated lookup failure cannot poison the step exit code.
            $LASTEXITCODE = 0
          }
        }

        $versionChanged = $true
        if ($prevVersion -and ($prevVersion -eq $current.Version)) {
          $versionChanged = $false
        }

        $doRelease = $isEligibleVersion -and $versionChanged -and (-not $remoteTagExists)

        Write-Host "Event: push to main"
        Write-Host "Current version: $($current.Version)"
        Write-Host "Previous version: $prevVersion"
        Write-Host "Eligible version (0.x.0): $isEligibleVersion"
        Write-Host "Version changed in push: $versionChanged"
        Write-Host "Remote tag exists ($tag): $remoteTagExists"
        Write-Host "Do release: $doRelease"

        $doReleaseFlag = if ($doRelease) { 'true' } else { 'false' }
        "do_release=$doReleaseFlag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        "tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        "version=$($current.Version)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
        exit 0

  build-and-release:
    name: Build and Publish (Windows)
    needs: decide
    if: needs.decide.outputs.do_release == 'true'
    runs-on: windows-latest

    steps:
    # =========================================================================
    # Checkout Repository
    # =========================================================================
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    # =========================================================================
    # Validate Required vcpkg Overlay Files
    # =========================================================================
    - name: Validate vcpkg overlay files
      run: |
        $ErrorActionPreference = 'Stop'

        $required = @(
          'vcpkg-overlays/ports/pcre2/portfile.cmake',
          'vcpkg-overlays/ports/icu/portfile.cmake',
          'vcpkg-overlays/ports/icu/vcpkg-cmake-wrapper.cmake',
          'vcpkg-overlays/ports/pcre2/vcpkg.json',
          'vcpkg-overlays/ports/icu/vcpkg.json'
        )

        $missing = $required | Where-Object { -not (Test-Path $_) }
        if ($missing.Count -gt 0) {
          $missing | ForEach-Object { Write-Host "Missing overlay file: $_" }
          throw "Overlay preflight failed."
        }

        Write-Host "Overlay preflight passed."

    # =========================================================================
    # Setup vcpkg
    # =========================================================================
    - name: Setup vcpkg
      uses: lukka/run-vcpkg@v11
      with:
        vcpkgGitCommitId: '39922dbab0cafd7a7150d459c6a181c7dee5dfbe'
        vcpkgJsonGlob: 'vcpkg.json'

    # =========================================================================
    # Cache vcpkg Dependencies
    # =========================================================================
    - name: Cache vcpkg Packages
      uses: actions/cache@v4
      with:
        path: |
          ${{ env.VCPKG_ROOT }}/archives
          ${{ env.VCPKG_ROOT }}/downloads
          build/release/vcpkg_installed
        key: ${{ runner.os }}-vcpkg-${{ hashFiles('vcpkg.json') }}
        restore-keys: |
          ${{ runner.os }}-vcpkg-

    # =========================================================================
    # Configure vcpkg GitHub Packages binary caching (NuGet)
    # =========================================================================
    - name: Configure vcpkg binary cache (NuGet)
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        $ErrorActionPreference = 'Stop'

        $vcpkgExe = Join-Path $env:VCPKG_ROOT 'vcpkg.exe'
        if (-not (Test-Path $vcpkgExe)) {
          throw "vcpkg.exe not found at '$vcpkgExe'"
        }

        $nugetExe = & $vcpkgExe fetch nuget
        if (-not (Test-Path $nugetExe)) {
          throw "nuget.exe not found at '$nugetExe'"
        }
        if ([string]::IsNullOrWhiteSpace($env:GITHUB_TOKEN)) {
          throw "GITHUB_TOKEN is empty; cannot configure NuGet binary cache."
        }
        if ([string]::IsNullOrWhiteSpace($env:FEED_URL)) {
          throw "FEED_URL is empty; cannot configure NuGet binary cache."
        }

        $nugetConfigPath = Join-Path $env:RUNNER_TEMP 'vcpkg-nuget.config'
        $feedUrlEscaped = [System.Security.SecurityElement]::Escape($env:FEED_URL)
        $nugetConfigContent = @"
        <?xml version="1.0" encoding="utf-8"?>
        <configuration>
          <config>
            <add key="defaultPushSource" value="$feedUrlEscaped" />
          </config>
          <packageSources>
            <clear />
            <add key="GitHub" value="$feedUrlEscaped" />
          </packageSources>
          <packageSourceCredentials>
            <GitHub>
              <add key="Username" value="%GITHUB_ACTOR%" />
              <add key="ClearTextPassword" value="%GITHUB_TOKEN%" />
            </GitHub>
          </packageSourceCredentials>
          <apikeys>
            <add key="$feedUrlEscaped" value="%GITHUB_TOKEN%" />
          </apikeys>
        </configuration>
        "@
        [System.IO.File]::WriteAllText($nugetConfigPath, $nugetConfigContent, [System.Text.UTF8Encoding]::new($false))
        "VCPKG_NUGET_CONFIG_PATH=$nugetConfigPath" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

        "VCPKG_BINARY_SOURCES=clear;nugetconfig,$nugetConfigPath,readwrite;default,readwrite" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

    # =========================================================================
    # Setup MSVC
    # =========================================================================
    - name: Setup MSVC
      uses: microsoft/setup-msbuild@v2
      with:
        msbuild-architecture: x64

    # =========================================================================
    # Configure CMake
    # =========================================================================
    - name: Configure CMake
      run: |
        cmake --preset windows-release
      env:
        VCPKG_ROOT: ${{ env.VCPKG_ROOT }}

    # =========================================================================
    # Build Project
    # =========================================================================
    - name: Build ExoSend
      run: |
        cmake --build build/release --config ${{ env.BUILD_CONFIGURATION }} --parallel

    # =========================================================================
    # Run Unit Tests
    # =========================================================================
    - name: Run Unit Tests
      working-directory: build/release
      run: |
        ctest -C ${{ env.BUILD_CONFIGURATION }} --verbose --output-on-failure --no-tests=error

    # =========================================================================
    # Build Installer (Inno Setup)
    # =========================================================================
    - name: Install Inno Setup
      run: |
        choco install innosetup -y

    - name: Build Installer
      run: |
        $ErrorActionPreference = 'Stop'

        $iscc = "${env:ProgramFiles(x86)}\\Inno Setup 6\\ISCC.exe"
        if (-not (Test-Path $iscc)) {
          throw "ISCC.exe not found at '$iscc'"
        }

        & $iscc "installers\\ExoSend.iss"

        $installerPath = "build\\installer\\ExoSend Installer.exe"
        if (-not (Test-Path $installerPath)) {
          throw "Installer output not found at '$installerPath'"
        }

    # =========================================================================
    # Package Release ZIP
    # =========================================================================
    - name: Package ZIP
      run: |
        $ErrorActionPreference = 'Stop'

        $buildDir = "build/release/bin/${{ env.BUILD_CONFIGURATION }}"
        $distDir = "dist"
        $stageDir = Join-Path $distDir "ExoSend"
        $zipPath = Join-Path $distDir "ExoSend.zip"

        if (-not (Test-Path $buildDir)) {
          throw "Build output directory not found: $buildDir"
        }

        Remove-Item -Recurse -Force $stageDir -ErrorAction SilentlyContinue
        New-Item -ItemType Directory -Path $stageDir -Force | Out-Null

        Copy-Item (Join-Path $buildDir "ExoSend.exe") $stageDir -Force
        Copy-Item (Join-Path $buildDir "ExoSendFirewallHelper.exe") $stageDir -Force
        Copy-Item (Join-Path $buildDir "*.dll") $stageDir -Force
        Copy-Item (Join-Path $buildDir "platforms") $stageDir -Recurse -Force
        Copy-Item (Join-Path $buildDir "styles") $stageDir -Recurse -Force

        $required = @(
          (Join-Path $stageDir "ExoSend.exe"),
          (Join-Path $stageDir "ExoSendFirewallHelper.exe"),
          (Join-Path $stageDir "Qt6Core.dll"),
          (Join-Path $stageDir "Qt6Gui.dll"),
          (Join-Path $stageDir "Qt6Widgets.dll"),
          (Join-Path $stageDir "libcrypto-3-x64.dll"),
          (Join-Path $stageDir "libssl-3-x64.dll"),
          (Join-Path $stageDir "platforms\\qwindows.dll"),
          (Join-Path $stageDir "styles\\qmodernwindowsstyle.dll")
        )

        $missing = $required | Where-Object { -not (Test-Path $_) }
        if ($missing.Count -gt 0) {
          $missing | ForEach-Object { Write-Host "Missing required runtime file: $_" }
          throw "Deployment completeness check failed."
        }

        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
        Compress-Archive -Path (Join-Path $stageDir "*") -DestinationPath $zipPath -Force

        Write-Host "Created: $zipPath"

    # =========================================================================
    # Publish GitHub Release
    # =========================================================================
    - name: Publish GitHub Release
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        $ErrorActionPreference = 'Stop'

        $tag = "${{ needs.decide.outputs.tag }}"
        $repo = "${{ github.repository }}"
        $sha = "${{ github.sha }}"
        $zipPath = "dist/ExoSend.zip"
        $installerPath = "build/installer/ExoSend Installer.exe"

        if (-not (Test-Path $zipPath)) {
          throw "ZIP not found at '$zipPath'"
        }
        if (-not (Test-Path $installerPath)) {
          throw "Installer not found at '$installerPath'"
        }

        $prerelease = $false
        if ($tag -match '^v0\\.') {
          $prerelease = $true
        }

        gh release view $tag --repo $repo *> $null
        $exists = ($LASTEXITCODE -eq 0)

        if (-not $exists) {
          $args = @($tag, $zipPath, $installerPath, "--repo", $repo, "--generate-notes", "--target", $sha)
          if ($prerelease) {
            $args += "--prerelease"
          }
          gh release create @args
        } else {
          gh release upload $tag $zipPath $installerPath --repo $repo --clobber
        }

    # =========================================================================
    # Cleanup Temporary NuGet Config
    # =========================================================================
    - name: Cleanup temporary NuGet config
      if: always()
      run: |
        $ErrorActionPreference = 'Continue'
        if (-not [string]::IsNullOrWhiteSpace($env:VCPKG_NUGET_CONFIG_PATH) -and (Test-Path $env:VCPKG_NUGET_CONFIG_PATH)) {
          Remove-Item -Path $env:VCPKG_NUGET_CONFIG_PATH -Force -ErrorAction Stop
          Write-Host "Temporary NuGet config removed."
        } else {
          Write-Host "No temporary NuGet config to remove."
        }
