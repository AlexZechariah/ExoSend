/**
 * @file TlsSocket.h
 * @brief TLS/SSL wrapper for secure socket communication
 */

#pragma once

#include "config.h"
#include <string>
#include <winsock2.h>
#include <openssl/ssl.h>
#include <openssl/err.h>

namespace ExoSend {

//=============================================================================
// TlsRole Enum
//=============================================================================

/**
 * @brief TLS connection role (server or client)
 */
enum class TlsRole {
    SERVER,  ///< Server mode - performs SSL_accept()
    CLIENT   ///< Client mode - performs SSL_connect()
};

//=============================================================================
// TlsSocket Class
//=============================================================================

/**
 * @class TlsSocket
 * @brief OpenSSL TLS wrapper around a Winsock SOCKET
 *
 * This class wraps a raw TCP socket with TLS encryption using OpenSSL.
 * It handles the TLS handshake and provides secure read/write methods.
 *
 * Architecture:
 * - Wraps an existing Winsock SOCKET with OpenSSL SSL*
 * - RAII-compliant resource management (SSL and SSL_CTX freed in destructor)
 * - Thread-safe for individual socket operations (one SSL per thread)
 * - Supports both server (SSL_accept) and client (SSL_connect) modes
 *
 * Security Features:
 * - TLS 1.2 minimum (SSLv3, TLSv1.0, TLSv1.1 disabled)
 * - Strong cipher suite (HIGH:!aNULL:!MD5:!3DES)
 * - ECDHE for forward secrecy
 * - No compression (CRIME attack prevention)
 * - Proper SSL error handling with ERR_get_error()
 *
 * Usage:
 * @code
 * // Server side
 * SOCKET clientSock = accept(listenSock, ...);
 * TlsSocket tls(clientSock, TlsRole::SERVER);
 * if (tls.handshake(errorMsg)) {
 *     tls.send(data, size, errorMsg);
 *     tls.recv(buffer, size, errorMsg);
 * }
 *
 * // Client side
 * SOCKET sock = socket(...);
 * connect(sock, ...);
 * TlsSocket tls(sock, TlsRole::CLIENT);
 * if (tls.handshake(errorMsg)) {
 *     // Transfer data securely
 * }
 * @endcode
 *
 * @note The underlying SOCKET is NOT closed by TlsSocket destructor.
 *       Caller is responsible for closing the original socket.
 */
class TlsSocket {
public:
    //=========================================================================
    // Constructor / Destructor
    //=========================================================================

    /**
     * @brief Constructor - wraps a raw TCP socket with TLS
     * @param socket Raw TCP socket to wrap (must be connected)
     * @param role Server or client mode
     *
     * The socket must already be connected (for client) or accepted (for server).
     * TLS handshake is performed by calling handshake() after construction.
     *
     * @param socket Connected TCP socket
     * @param role TlsRole::SERVER or TlsRole::CLIENT
     */
    TlsSocket(SOCKET socket, TlsRole role);

    /**
     * @brief Destructor - cleans up SSL and SSL_CTX resources
     *
     * Calls SSL_shutdown() if connected, then frees SSL and SSL_CTX.
     * Does NOT close the underlying socket (caller's responsibility).
     */
    ~TlsSocket();

    // Prevent copying (SSL objects cannot be copied)
    TlsSocket(const TlsSocket&) = delete;
    TlsSocket& operator=(const TlsSocket&) = delete;

    // Allow moving (transfer ownership of SSL resources)
    TlsSocket(TlsSocket&&) noexcept;
    TlsSocket& operator=(TlsSocket&&) noexcept;

    //=========================================================================
    // TLS Handshake
    //=========================================================================

    /**
     * @brief Perform TLS handshake
     * @param errorMsg Output error message on failure
     * @return true if handshake successful, false on error
     *
     * This method:
     * 1. Creates SSL_CTX with security options
     * 2. Loads certificate (server mode only)
     * 3. Creates SSL object and attaches to socket
     * 4. Performs SSL_accept() (server) or SSL_connect() (client)
     *
     * Both server and client load local certificates (generated by CertificateManager).
     * The application enforces pairing and pinning by comparing the peer certificate
     * fingerprint against the persisted trust store.
     *
     * @param errorMsg Output error message
     * @return true on success, false on failure
     */
    bool handshake(std::string& errorMsg);

    //=========================================================================
    // Send / Receive
    //=========================================================================

    /**
     * @brief Send data over TLS connection
     * @param data Data buffer to send
     * @param size Number of bytes to send
     * @param errorMsg Output error message on failure
     * @return true if all bytes sent successfully, false on error
     *
     * Internally loops SSL_write() until all bytes are sent.
     * Handles SSL_ERROR_WANT_WRITE for non-blocking I/O.
     *
     * @param data Data to send
     * @param size Size of data
     * @param errorMsg Output error message
     * @return true on success
     */
    bool send(const uint8_t* data, size_t size, std::string& errorMsg);

    /**
     * @brief Receive data from TLS connection
     * @param buffer Buffer to receive data
     * @param size Number of bytes to receive
     * @param errorMsg Output error message on failure
     * @return Number of bytes received, or 0 on error/connection close
     *
     * Internally loops SSL_read() until all bytes are received.
     * Handles SSL_ERROR_WANT_READ for non-blocking I/O.
     *
     * @param buffer Receive buffer
     * @param size Size of buffer
     * @param errorMsg Output error message
     * @return Number of bytes received, or 0 on error
     */
    size_t recv(uint8_t* buffer, size_t size, std::string& errorMsg);

    /**
     * @brief Send exact number of bytes (loops until complete)
     * @param data Data to send
     * @param size Number of bytes to send
     * @param errorMsg Output error message
     * @return true if all bytes sent
     *
     * Convenience wrapper that loops send() until all bytes sent.
     */
    bool sendExact(const uint8_t* data, size_t size, std::string& errorMsg);

    /**
     * @brief Receive exact number of bytes (loops until complete)
     * @param buffer Receive buffer
     * @param size Number of bytes to receive
     * @param errorMsg Output error message
     * @return true if all bytes received
     *
     * Convenience wrapper that loops recv() until all bytes received.
     * Returns false if connection closes before receiving all bytes.
     */
    bool recvExact(uint8_t* buffer, size_t size, std::string& errorMsg);

    //=========================================================================
    // Connection Management
    //=========================================================================

    /**
     * @brief Shutdown TLS connection gracefully
     *
     * Calls SSL_shutdown() to perform TLS close notify.
     * Does NOT close the underlying socket.
     */
    void shutdown();

    /**
     * @brief Check if TLS handshake is complete
     * @return true if handshake completed successfully
     */
    bool isConnected() const { return m_connected; }

    /**
     * @brief Get underlying socket
     * @return Raw Winsock SOCKET
     *
     * Use sparingly - direct socket operations bypass TLS encryption.
     */
    SOCKET getSocket() const { return m_socket; }

    //=========================================================================
    // Certificate Information
    //=========================================================================

    /**
     * @brief Get peer certificate fingerprint (SHA-256)
     * @param errorMsg Output error message
     * @return Hexadecimal fingerprint string (64 characters), or empty on error
     *
     * Extracts peer certificate and computes SHA-256 hash.
     * Useful for displaying to users for manual verification.
     *
     * @return Certificate fingerprint or empty string
     */
    std::string getPeerFingerprint(std::string& errorMsg);

    /**
     * @brief Get peer certificate common name (CN)
     * @param errorMsg Output error message
     * @return Common name from certificate, or empty on error
     */
    std::string getPeerCommonName(std::string& errorMsg);

    //=========================================================================
    // Error Handling
    //=========================================================================

    /**
     * @brief Get last OpenSSL error as string
     * @return Human-readable error message
     *
     * Uses ERR_get_error() to retrieve from OpenSSL error queue.
     * Call this after any OpenSSL operation fails.
     *
     * @return Error message string
     */
    static std::string getLastError();

    /**
     * @brief Get SSL error description
     * @param sslErrorCode Error code from SSL_get_error()
     * @return Human-readable description
     *
     * Converts SSL_ERROR_* codes to descriptive strings.
     *
     * @param sslErrorCode SSL error code
     * @return Error description
     */
    static std::string getErrorDescription(int sslErrorCode);

private:
    //=========================================================================
    // Private Methods
    //=========================================================================

    /**
     * @brief Create SSL context with security options
     * @param errorMsg Output error message
     * @return true if successful
     *
     * Configures SSL_CTX with:
     * - Minimum TLS version (1.2)
     * - Strong cipher list
     * - Security options (no compression, forward secrecy)
     * - ECDHE auto mode
     */
    bool createContext(std::string& errorMsg);

    /**
     * @brief Load certificate and private key (server mode only)
     * @param errorMsg Output error message
     * @return true if successful
     *
     * Loads certificate and key from %APPDATA%\ExoSend\certs\
     * Verifies private key matches certificate.
     */
    bool loadCertificates(std::string& errorMsg);

    /**
     * @brief Create SSL object from context
     * @param errorMsg Output error message
     * @return true if successful
     *
     * Creates SSL object and attaches to underlying socket.
     */
    bool createSsl(std::string& errorMsg);

    /**
     * @brief Configure SSL verification mode
     * @param errorMsg Output error message
     * @return true if successful
     *
     * For alpha: accepts self-signed certificates
     * For beta: should implement proper certificate verification
     */
    bool configureVerification(std::string& errorMsg);

    //=========================================================================
    // Member Variables
    //=========================================================================

    SOCKET m_socket;           ///< Underlying TCP socket (owned by caller)
    SSL_CTX* m_ctx;            ///< OpenSSL SSL context
    SSL* m_ssl;                ///< OpenSSL SSL object
    TlsRole m_role;            ///< Server or client mode
    bool m_connected;          ///< Handshake complete flag
    bool m_initialized;        ///< SSL objects initialized flag
};

//=============================================================================
// Certificate Verification Callback (for future use)
//=============================================================================

/**
 * @brief Certificate verification callback
 *
 * For alpha: Always returns 1 (accept self-signed certificates)
 * For beta: Should implement proper certificate validation
 *
 * @param preverifyOk Result of X509 certificate verification
 * @param ctx X509 store context
 * @return 1 to accept certificate, 0 to reject
 */
int tlsVerifyCallback(int preverifyOk, X509_STORE_CTX* ctx);

//=============================================================================
// Utility Functions
//=============================================================================

/**
 * @brief Initialize OpenSSL library (call once at startup)
 *
 * Loads SSL strings and registers SSL algorithms.
 * Safe to call multiple times (idempotent).
 */
void initOpenSsl();

/**
 * @brief Cleanup OpenSSL library (call once at shutdown)
 *
 * Frees OpenSSL resources.
 */
void cleanupOpenSsl();

}  // namespace ExoSend
